# üåÄ ASCII Maze Game Solver and Player  
![Immagine 2024-09-14 102840](https://github.com/user-attachments/assets/78662f41-aa87-4c1c-8d1a-0cb16e9cca24)

**GROUP: Costa, Munarin, Minardi**  
This project is part of the 'Introduction to Programming' university course, focusing on building an algorithm in F# to solve and play a labyrinth game using the **ASCII-Maze game engine** developed by Prof. Span√≤.  

## üìñ Overview  

The Maze Game project demonstrates advanced problem-solving and algorithm development using functional programming. The core goal is to generate a maze, allow a player to navigate it, and implement various modes for solving and visualizing the maze. This README outlines the modifications, approaches, and key features of the implementation.  

## üõ†Ô∏è Project Features  

- **Maze Generation**: Procedurally generated maze with walls and pathways.  
- **Game Modes**: 
  - *Normal Mode*: Navigate through the maze manually.  
  - *Auto-Resolve Mode*: Visualize the solution generated by the algorithm.  
  - *Animation Mode*: Animate the solution step-by-step.  
- **Dynamic Menu**: Interactive menu for selecting game options such as mode, width, and height.  
- **Graphical Enhancements**: Color-coded maze paths, walls, and solution.  

## üèóÔ∏è Key Modifications  

### Config  
- Customized the wall and player symbols using ASCII characters ('/219' for filled squares).  

### Graphics (GFX)  
- Added a method for graphical representation of walls with color:  
  'static member filled_wall (fg : Color, ?bg : Color) = CharInfo.create (Config.wall_pixel_char, fg, ?bg = bg)'
- Commented out console logging code to reduce clutter.  

### Engine  
- Introduced a global variable 'ShowFPS' to toggle FPS display.  
- Modified logging behavior to prevent unnecessary debug information.  

### Maze Class  
The maze class forms the backbone of the project, with extensive functionality:  

#### Attributes:  
- **Walls**: Represents the maze structure, using a matrix where 'true' indicates a wall and 'false' a path.  
- **Resolved**: Stores the solution path:  
  - '0': Open path  
  - '1': Blocked or visited  
  - '2': To be checked  
  - '3': Initial state  

#### Methods:  
1. **Generate**: Creates a maze starting from '(1,1)' using recursive backtracking with random directions.  
2. **Generate Random Exit**: Adds a random exit ensuring it connects to a path.  
3. **Auto-Resolve**: Automatically solves the maze using a custom algorithm to mark paths and dead-ends.  
4. **Player Start Position**: Generates a random starting position for the player within the maze.  

### Game Modes  

#### Normal Mode  
- The player navigates the maze using 'W/A/S/D'.  
- Prevents movement outside the maze or through walls.  
- Displays a 'SUCCESS' message upon reaching the exit.  

#### Auto-Resolve Mode  
- Automatically generates and displays the maze solution.  
- Three sub-modes:  
  - *Solution*: Displays the solution without player interaction.  
  - *Playable*: Allows the player to follow and overwrite the solution path.  
  - *Animation*: Animates the solution step-by-step as the player moves.  
![Immagine 2024-09-14 102833](https://github.com/user-attachments/assets/7b131529-ca52-4af5-8d17-798f3e535417)

### Menu System  
- Interactive menu for selecting game options (e.g., mode, width, height).  
- Dynamically updates menu elements to ensure smooth transitions.  

### Music  
- Added the option for background music during gameplay (optional).  

## üîç Implementation Details  

- **Recursive Backtracking**: Used for maze generation, ensuring all paths are reachable.  
- **Randomized Directions**: Ensures unique mazes each time.  
- **Dead-End Detection**: Identifies and handles dead-end paths in the maze.  
- **Path Animation**: Smoothly visualizes the solution path using graphical updates.  

## üß™ Testing  

- All functionality tested rigorously within the constraints of Prof. Span√≤'s engine.  
- Verified correct maze generation, player controls, and solution visualization.  

## üí° Learning Outcomes  

- Understanding functional programming principles in F#.  
- Implementing maze-solving algorithms using recursion and backtracking.  
- Advanced use of game engines for graphical representation and interactivity.  
- Designing and debugging interactive applications in F#.  

## üöÄ How to Run  

1. Clone the repository and set up the environment for F# development.  
2. Ensure the **ASCII-Maze Engine** by Prof. Span√≤ is included in the project.  
3. Run the program and navigate the menu to select game options.  

## üìú License  

This project is open source and available under the MIT License.  
